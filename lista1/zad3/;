#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>

const int max_node = 1000000;
std::vector<int> graph[max_node];              //store graph's adjacency list
std::vector<int> transpose_graph[max_node];    //store transpose graph's adjacency list
std::vector<int> sizes;			       //store size of ssc's
bool vis[max_node];                       //store node visit stat for dfs

std::vector<int> node_order;  
int numOfNodes;			

//this function travels the whole graph and puts the nodes in a node_order
//the nodes are pushed in order of their finish time
void dfs(int n)
{
    	if(vis[n]) return;  //if node is already visited
    
    	int len = graph[n].size();
    	vis[n]= true;
    
    	for(int i = 0; i < len; i++)
    	{
        	dfs(graph[n][i]);
    	}
    
    	node_order.push_back(n);
}


//this function traverses the transpose graph
// at each call traverses a SCC and prints each node of that SCC to std output
void dfs_print(int n)
{
    	if (vis[n] == true) return;  //if node is already visited
   	
       	if(numOfNodes >= 200) std:: cout << n << " ";
    
    	int len = transpose_graph[n].size();
    	vis[n] = true;
    
    	for (int i = 0; i < len; i++)
    	{
        	dfs_print(transpose_graph[n][i]);
    	}
}

//n nodes
// print each SCC nodes in separate line
// and return the number of SCC in that graph
int kosarajuSCC(int n)
{
    	int scc_count= 0;   //keep count of strongly connected components
    	for (int i = 1; i <= n; i++)
    	{
        	if(vis[i] == false)
		{
            		dfs(i);
        	}
    	}
    
    	for(int i = 1; i <= n; i++)
    	{
        	vis[i]= false;
    	}
    
    	for (int i = node_order.size() - 1; i >= 1; i--)
    	{
        	if (vis[node_order[i]] == false)
		{
            		dfs_print(node_order[i]);
            		scc_count++;
	  	  	std::cout << std::endl;
        	}  
    	}
    
    	node_order.clear();
    	return scc_count;
}

int main(void)
{    
    	int n; //n nodes
    	int m; //m edges
    	int u; //start node of an edge
    	int v; //end node of an edge
	char c;
	std::cin >> c;	
    	std::cin >> n >> m;
	numOfNodes = n;    
    
    	//initialize
    	for(int i= 0; i<= n; i++)
    	{
        	vis[i]= false;
        	graph[i].clear();
        	transpose_graph[i].clear();
    	}
    
    	//take graph input as adjacency list
    	for (int i = 0; i < m; i++)
	{
		std::cin >> u >> v;     //edge u -> v
        
        	graph[u].push_back(v);
        	transpose_graph[v].push_back(u);
    	}
    
    	int components = kosarajuSCC(n);
	std::cout << "Components: " << components << std::endl;
    
    
    return 0;
}
